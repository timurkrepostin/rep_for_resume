** https://starkovden.github.io/authentication-and-authorization.html
Требования аутентификации и авторизации API

Прежде чем пользователи смогут отправлять запросы с помощью API, им обычно необходимо
зарегистрироваться для получения ключа API или изучить другие способы аутентификации
запросов. API-интерфейсы различаются по способу аутентификации пользователей. Некоторые
API требуют включения ключа API в заголовок запроса, в то время как другие API требуют
тщательной защиты из-за необходимости защиты конфиденциальных данных, подтверждения
личности и обеспечения того, чтобы запросы не были подделаны.
Определяем термины
Во-первых, давайте определимся с некоторыми ключевыми терминами:
Аутентификация: подтверждение правильности личности
Авторизация: разрешение определенного действия
API может аутентифицировать, но не разрешит делать определенный запрос.
Последствия нехватки безопасности API
Почему даже API-интерфейсы нуждаются в аутентификации? Для API, которые предназначены
только для чтения, иногда пользователям не нужны ключи. Но большинство коммерческих API
требуют авторизации в виде ключей API или других методов. Если нет никакой защиты API,
пользователи могут совершать неограниченное количество запросов API без какой-либо
регистрации. 
Вдобавок, без аутентификации не было бы простого способа связать запросы с конкретными
данными пользователя. И не было бы способа защиты от запросов от злонамеренных
пользователей, которые могут удалить данные другого пользователя (например, путем
удаления запросов DELETE для учетной записи другого пользователя).
Наконец, не получится отследить, кто использует API или какие конечные точки используются
чаще всего. Очевидно, что разработчики API должны подумать о способах аутентификации и
авторизации запросов к своим API.
● В целом, аутентификация и авторизация с помощью API служат следующим целям:
аутентификация запросов в API только для зарегистрированных пользователей;
отслеживание, кто делает запросы;
отслеживание использования API;
блокировка или замедление пользователя, превышающего ограничения скорости;
применение разных уровней разрешений для разных пользователей.

Разные виды авторизации
Существует несколько методов авторизации. Ниже рассмотрим несколько вариантов авторизации,
которые встречаются чаще всего:
API ключ
Basic Auth
HMAC
OAuth 2.0

● API ключ
Большинство API требуют авторизации ключом API, чтобы использовать API. Ключ API
представляет собой длинную строку, которую обычно включают либо в URL запроса, либо в
заголовок запроса. Ключ API в основном служит способом идентификации лица, выполняющего
запрос API (аутентифицируя для использования API). Ключ API также может быть связан с
конкретным приложением, которое регистрируется.

● Basic Auth
Другой тип авторизации называется Basic Auth. С помощью этого метода отправитель помещает
пару имя пользователя:пароль в заголовок запроса. Имя пользователя и пароль кодируются
с помощью Base64, который представляет собой метод кодирования, который преобразует имя
пользователя и пароль в набор из 64 символов для обеспечения безопасной передачи.
Вот пример Basic Auth в заголовке запроса:
Authorization: Basic bG9sOnNlY3VyZQ==
API, использующие Basic Auth, также будут использовать HTTPS, что означает, что
содержимое сообщения будет зашифровано в транспортном протоколе HTTP. (Без HTTPS людям
было бы легко расшифровать зашифрованные данные)
Когда сервер API получает сообщение, он дешифрует сообщение и проверяет заголовок. После
декодирования строки и анализа имени пользователя и пароля он решает, принять или
отклонить запрос.
В Postman можно настроить базовую авторизацию, щелкнув вкладку Authorization, выбрав Basic
Auth в раскрывающемся списке и введя имя пользователя и пароль справа от двоеточия в
каждой строке. На вкладке Заголовки будет показана пара ключ-значение, выглядящая
следующим образом:
Authorization: Basic RnJlZDpteXBhc3N3b3Jk
Postman обрабатывает кодировку Base64 автоматически, при вводе имени пользователя и
пароля с выбранным Basic Auth.

● HMAC (код авторизации сообщений на основе хэша)
HMAC расшифровывается как Hash-based message authorization code - код авторизации
сообщений на основе хэша и является более строгим типом аутентификации, более
распространенным в финансовых API. В HMAC только отправитель, и получатель знают секретный
ключ, который больше неизвестен никому. Отправитель создает сообщение на основе некоторых
системных свойств (например, отметка времени запроса плюс идентификатор учетной записи).
Затем сообщение кодируется секретным ключом и проходит через алгоритм безопасного
хеширования (SHA - secure hashing algorithm). (Хеш - это зашифрованная строка на основе
алгоритма.) Результирующее значение, называемое сигнатурой, помещается в заголовок запроса.
Сервер API (получатель), получая запрос, принимает те же системные свойства (отметка
времени запроса плюс идентификатор учетной записи) и использует секретный ключ (который
известен только запрашивающей стороне и серверу API) и SHA для генерации одной и той же
строки. Если строка соответствует подписи в заголовке запроса, запрос принимается. Если
строки не совпадают, запрос отклоняется.
Важным моментом является то, что секретный ключ (критический для восстановления хэша)
известен только отправителю и получателю. Секретный ключ не включается в запрос.
Безопасность HMAC используется, когда нужно убедиться, что запрос является подлинным
и не может быть подделан

● OAuth 2.0
Одним из популярных методов аутентификации и авторизации пользователей является OAuth 2.0.
Такой подход опирается на сервер аутентификации для связи с сервером API для
предоставления доступа. Понять, что используется метод OAuth 2.0, можно когда предлагается
войти в систему при помощи сторонних сервисов, как Twitter, Google или Facebook.
Существует несколько разновидностей OAuth, а именно «one-legged OAuth» и «three-legged
OAuth». One-legged OAuth используется, когда нет конфиденциальных данных для защиты.
Например, в том случае, если просто получаем общую информацию только для чтения.
Three-legged OAuth используется, когда нужно защитить конфиденциальные данные. В этом
сценарии взаимодействуют три группы:
сервер аутентификации;
сервер API;
пользователь или приложение.

Базовый процесс Oauth2.0:
Сначала пользовательское приложение отправляет ключ приложения и секретные данные на
страницу входа в систему на сервере аутентификации. Если аутентификация пройдена, сервер
аутентификации возвращает пользователю токен доступа (авторизации).
Токен доступа (авторизации) упакован в параметр запроса в перенаправлении ответа (302)
на запрос. Перенаправление направляет запрос пользователя обратно на сервер ресурсов
(сервер API).
Затем пользователь отправляет запрос на сервер ресурсов (сервер API). Токен доступа
(авторизации) добавляется в заголовок запроса API со словом Bearer, за которым следует
строка токена. Сервер API проверяет токен доступа (авторизации) в запросе пользователя
и решает, аутентифицировать ли пользователя.
Токены доступа (авторизации) не только обеспечивают аутентификацию для запрашивающей
стороны, но и определяют права пользователя на использование API. Кроме того, токены
доступа (авторизации) обычно истекают через некоторое время и требуют от пользователя
повторного входа в систему.

** https://habr.com/ru/company/dataart/blog/262817/
Обзор способов и протоколов аутентификации в веб-приложениях

Идентификация — это заявление о том, кем вы являетесь. В зависимости от ситуации, это
может быть имя, адрес электронной почты, номер учетной записи, итд.
Аутентификация — предоставление доказательств, что вы на самом деле есть тот, кем
идентифицировались (от слова “authentic” — истинный, подлинный).
Авторизация — проверка, что вам разрешен доступ к запрашиваемому ресурсу.
под идентификацией понимают получение вашей учетной записи (identity) по username или
email; под аутентификацией — проверку, что вы знаете пароль от этой учетной записи,
а под авторизацией — проверку вашей роли в системе и решение о предоставлении доступа
к запрошенной странице или ресурсу.

Аутентификация по паролю
Этот метод основывается на том, что пользователь должен предоставить username и password
для успешной идентификации и аутентификации в системе. Пара username/password задается
пользователем при его регистрации в системе, при этом в качестве username может выступать
адрес электронной почты пользователя.

● HTTP authentication
Этот протокол, описанный в стандартах HTTP 1.0/1.1, существует очень давно и до сих пор
активно применяется в корпоративной среде. Применительно к веб-сайтам работает следующим
образом:
Сервер, при обращении неавторизованного клиента к защищенному ресурсу, отсылает HTTP
статус “401 Unauthorized” и добавляет заголовок “WWW-Authenticate” с указанием схемы и
параметров аутентификации.
Браузер, при получении такого ответа, автоматически показывает диалог ввода username и
password. Пользователь вводит детали своей учетной записи.
Во всех последующих запросах к этому веб-сайту браузер автоматически добавляет HTTP
заголовок “Authorization”, в котором передаются данные пользователя для аутентификации
сервером.
Сервер аутентифицирует пользователя по данным из этого заголовка. Решение о
предоставлении доступа (авторизация) производится отдельно на основании роли
пользователя, ACL или других данных учетной записи.
Весь процесс стандартизирован и хорошо поддерживается всеми браузерами и веб-серверами.
Существует несколько схем аутентификации, отличающихся по уровню безопасности:
- Basic — наиболее простая схема, при которой username и password пользователя передаются
в заголовке Authorization в незашифрованном виде (base64-encoded). Однако при
использовании HTTPS (HTTP over SSL) протокола, является относительно безопасной.
- Digest — challenge-response-схема, при которой сервер посылает уникальное значение
nonce, а браузер передает MD5 хэш пароля пользователя, вычисленный с использованием
указанного nonce. Более безопасная альтернативв Basic схемы при незащищенных соединениях,
но подвержена man-in-the-middle attacks (с заменой схемы на basic). Кроме того,
использование этой схемы не позволяет применить современные хэш-функции для хранения
паролей пользователей на сервере.
- NTLM (известная как Windows authentication) — также основана на challenge-response
подходе, при котором пароль не передается в чистом виде. Эта схема не является стандартом
HTTP, но поддерживается большинством браузеров и веб-серверов. Преимущественно
используется для аутентификации пользователей Windows Active Directory в веб-приложениях.
Уязвима к pass-the-hash-атакам.
- Negotiate — еще одна схема из семейства Windows authentication, которая позволяет
клиенту выбрать между NTLM и Kerberos аутентификацией. Kerberos — более безопасный
протокол, основанный на принципе Single Sign-On. Однако он может функционировать,
только если и клиент, и сервер находятся в зоне intranet и являются частью домена Windows.

● Forms authentication
Для этого протокола нет определенного стандарта, поэтому все его реализации специфичны
для конкретных систем, а точнее, для модулей аутентификации фреймворков разработки.
Работает это по следующему принципу: в веб-приложение включается HTML-форма, в
которую пользователь должен ввести свои username/password и отправить их на сервер через
HTTP POST для аутентификации. В случае успеха веб-приложение создает session token,
который обычно помещается в browser cookies. При последующих веб-запросах session token
автоматически передается на сервер и позволяет приложению получить информацию о текущем
пользователе для авторизации запроса.
Приложение может создать session token двумя способами:
Как идентификатор аутентифицированной сессии пользователя, которая хранится в памяти
сервера или в базе данных. Сессия должна содержать всю необходимую информацию о
пользователе для возможности авторизации его запросов.
Как зашифрованный и/или подписанный объект, содержащий данные о пользователе, а также
период действия. Этот подход позволяет реализовать stateless-архитектуру сервера, однако
требует механизма обновления сессионного токена по истечении срока действия. Несколько
стандартных форматов таких токенов рассматриваются в секции «Аутентификация по токенам».

● Аутентификация по сертификатам
Сертификат представляет собой набор атрибутов, идентифицирующих владельца, подписанный
certificate authority (CA). CA выступает в роли посредника, который гарантирует
подлинность сертификатов (по аналогии с ФМС, выпускающей паспорта). Также сертификат
криптографически связан с закрытым ключом, который хранится у владельца сертификата и
позволяет однозначно подтвердить факт владения сертификатом.
На стороне клиента сертификат вместе с закрытым ключом могут храниться в операционной
системе, в браузере, в файле, на отдельном физическом устройстве (smart card, USB token).
Обычно закрытый ключ дополнительно защищен паролем или PIN-кодом.
В веб-приложениях традиционно используют сертификаты стандарта X.509. Аутентификация с
помощью X.509-сертификата происходит в момент соединения с сервером и является частью
протокола SSL/TLS. Этот механизм также хорошо поддерживается браузерами, которые
позволяют пользователю выбрать и применить сертификат, если веб-сайт допускает такой
способ аутентификации.
После успешной аутентификации веб-приложение может выполнить авторизацию запроса на
основании таких данных сертификата, как subject (имя владельца), issuer (эмитент), serial
number (серийный номер сертификата) или thumbprint (отпечаток открытого ключа сертификата).
Использование сертификатов для аутентификации — куда более надежный способ, чем
аутентификация посредством паролей. Это достигается созданием в процессе аутентификации
цифровой подписи, наличие которой доказывает факт применения закрытого ключа в конкретной
ситуации (non-repudiation). Однако трудности с распространением и поддержкой сертификатов
делает такой способ аутентификации малодоступным в широких кругах.

● Аутентификация по одноразовым паролям
Аутентификация по одноразовым паролям обычно применяется дополнительно к аутентификации
по паролям для реализации two-factor authentication (2FA). В этой концепции пользователю
необходимо предоставить данные двух типов для входа в систему: что-то, что он знает
(например, пароль), и что-то, чем он владеет (например, устройство для генерации
одноразовых паролей). Наличие двух факторов позволяет в значительной степени увеличить
уровень безопасности, что м. б. востребовано для определенных видов веб-приложений.
Другой популярный сценарий использования одноразовых паролей — дополнительная
аутентификация пользователя во время выполнения важных действий: перевод денег,
изменение настроек и т. п.
Существуют разные источники для создания одноразовых паролей. Наиболее популярные:
Аппаратные или программные токены, которые могут генерировать одноразовые пароли на
основании секретного ключа, введенного в них, и текущего времени. Секретные ключи
пользователей, являющиеся фактором владения, также хранятся на сервере, что позволяет
выполнить проверку введенных одноразовых паролей. Пример аппаратной реализаций токенов
— RSA SecurID; программной — приложение Google Authenticator.
Случайно генерируемые коды, передаваемые пользователю через SMS или другой канал связи.
В этой ситуации фактор владения — телефон пользователя (точнее — SIM-карта, привязанная
к определенному номеру).
Распечатка или scratch card со списком заранее сформированных одноразовых паролей.
Для каждого нового входа в систему требуется ввести новый одноразовый пароль с указанным
номером.
В веб-приложениях такой механизм аутентификации часто реализуется посредством расширения
forms authentication: после первичной аутентификации по паролю, создается сессия
пользователя, однако в контексте этой сессии пользователь не имеет доступа к приложению
до тех пор, пока он не выполнит дополнительную аутентификацию по одноразовому паролю.

● Аутентификация по ключам доступа
Этот способ чаще всего используется для аутентификации устройств, сервисов или других
приложений при обращении к веб-сервисам. Здесь в качестве секрета применяются ключи доступа
(access key, API key) — длинные уникальные строки, содержащие произвольный набор символов,
по сути заменяющие собой комбинацию username/password.
В большинстве случаев, сервер генерирует ключи доступа по запросу пользователей, которые далее
сохраняют эти ключи в клиентских приложениях. При создании ключа также возможно ограничить
срок действия и уровень доступа, который получит клиентское приложение при аутентификации
с помощью этого ключа.
Хороший пример применения аутентификации по ключу — облако Amazon Web Services. Предположим,
у пользователя есть веб-приложение, позволяющее загружать и просматривать фотографии, и он
хочет использовать сервис Amazon S3 для хранения файлов. В таком случае, пользователь через
консоль AWS может создать ключ, имеющий ограниченный доступ к облаку: только чтение/запись
его файлов в Amazon S3. Этот ключ в результате можно применить для аутентификации веб-приложения
в облаке AWS.
С технической точки зрения, здесь не существует единого протокола: ключи могут передаваться
в разных частях HTTP-запроса: URL query, request body или HTTP header. Как и в случае
аутентификации по паролю, наиболее оптимальный вариант — использование HTTP header.
В некоторых случаях используют HTTP-схему Bearer для передачи токена в заголовке
(Authorization: Bearer [token]). Чтобы избежать перехвата ключей, соединение с сервером
должно быть обязательно защищено протоколом SSL/TLS.

● Аутентификация по токенам

Такой способ аутентификации чаще всего применяется при построении распределенных систем
Single Sign-On (SSO), где одно приложение (service provider или relying party) делегирует
функцию аутентификации пользователей другому приложению (identity provider или authentication
service). Типичный пример этого способа — вход в приложение через учетную запись в социальных
сетях. Здесь социальные сети являются сервисами аутентификации, а приложение доверяет функцию
аутентификации пользователей социальным сетям.
Реализация этого способа заключается в том, что identity provider (IP) предоставляет
достоверные сведения о пользователе в виде токена, а service provider (SP) приложение использует
этот токен для идентификации, аутентификации и авторизации пользователя.
На общем уровне, весь процесс выглядит следующим образом:
1. Клиент аутентифицируется в identity provider одним из способов, специфичным для него (пароль,
ключ доступа, сертификат, Kerberos, итд.).
2. Клиент просит identity provider предоставить ему токен для конкретного SP-приложения. Identity
provider генерирует токен и отправляет его клиенту.
3. Клиент аутентифицируется в SP-приложении при помощи этого токена.
Процесс, описанный выше, отражает механизм аутентификации активного клиента, т. е. такого,
который может выполнять запрограммированную последовательность действий (например, iOS/Android
приложения). Браузер же — пассивный клиент в том смысле, что он только может отображать
страницы, запрошенные пользователем. В этом случае аутентификация достигается посредством
автоматического перенаправления браузера между веб-приложениями identity provider и service
provider.

Существует несколько стандартов, в точности определяющих протокол взаимодействия между
клиентами (активными и пассивными) и IP/SP-приложениями и формат поддерживаемых токенов.
Среди наиболее популярных стандартов — OAuth, OpenID Connect, SAML, и WS-Federation. Некоторая
информация об этих протоколах — ниже в статье.
Сам токен обычно представляет собой структуру данных, которая содержит информацию, кто
сгенерировал токен, кто может быть получателем токена, срок действия, набор сведений о самом
пользователе (claims). Кроме того, токен дополнительно подписывается для предотвращения
несанкционированных изменений и гарантий подлинности.
При аутентификации с помощью токена SP-приложение должно выполнить следующие проверки:
1. Токен был выдан доверенным identity provider приложением (проверка поля issuer).
2. Токен предназначается текущему SP-приложению (проверка поля audience).
3. Срок действия токена еще не истек (проверка поля expiration date).
4. Токен подлинный и не был изменен (проверка подписи).
В случае успешной проверки SP-приложение выполняет авторизацию запроса на основании данных
о пользователе, содержащихся в токене.

Форматы токенов
Существует несколько распространенных форматов токенов для веб-приложений:

Simple Web Token (SWT) — наиболее простой формат, представляющий собой набор произвольных
пар имя/значение в формате кодирования HTML form. Стандарт определяет несколько
зарезервированных имен: Issuer, Audience, ExpiresOn и HMACSHA256. Токен подписывается с
помощью симметричного ключа, таким образом оба IP- и SP-приложения должны иметь этот ключ
для возможности создания/проверки токена.
Пример SWT токена (после декодирования).
Issuer=http://auth.myservice.com&
Audience=http://myservice.com&
ExpiresOn=1435937883&
UserName=John Smith&
UserRole=Admin&
HMACSHA256=KOUQRPSpy64rvT2KnYyQKtFFXUIggnesSpE7ADA4o9w

JSON Web Token (JWT) — содержит три блока, разделенных точками: заголовок, набор полей
(claims) и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы
в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT
определяет несколько зарезервированных имен (iss, aud, exp и другие). Подпись может
генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того,
существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.
Пример подписанного JWT токена (после декодирования 1 и 2 блоков).
{ «alg»: «HS256», «typ»: «JWT» }.
{ «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: «John Smith», «userRole»: «Admin» }.
S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY

Security Assertion Markup Language (SAML) — определяет токены (SAML assertions) в XML-формате,
включающем информацию об эмитенте, о субъекте, необходимые условия для проверки токена, набор
дополнительных утверждений (statements) о пользователе. Подпись SAML-токенов осуществляется
при помощи ассиметричной криптографии. Кроме того, в отличие от предыдущих форматов,
SAML-токены содержат механизм для подтверждения владения токеном, что позволяет предотвратить
перехват токенов через man-in-the-middle-атаки при использовании незащищенных соединений.

● Стандарт SAML
Стандарт Security Assertion Markup Language (SAML) описывает способы взаимодействия и протоколы
между identity provider и service provider для обмена данными аутентификации и авторизации
посредством токенов. Изначально версии 1.0 и 1.1 были выпущены в 2002 – 2003 гг., в то время
как версия 2.0, значительно расширяющая стандарт и обратно несовместимая, опубликована в 2005 г.
Этот основополагающий стандарт — достаточно сложный и поддерживает много различных сценариев
интеграции систем. Основные «строительные блоки» стандарта:
Assertions — собственный формат SAML токенов в XML формате.
Protocols — набор поддерживаемых сообщений между участниками, среди которых — запрос на
создание нового токена, получение существующих токенов, выход из системы (logout), управление
идентификаторами пользователей, и другие.
Bindings — механизмы передачи сообщений через различные транспортные протоколы. Поддерживаются
такие способы, как HTTP Redirect, HTTP POST, HTTP Artifact (ссылка на сообщения), SAML SOAP,
SAML URI (адрес получения сообщения) и другие.
Profiles — типичные сценарии использования стандарта, определяющие набор assertions, protocols
и bindings необходимых для их реализации, что позволяет достичь лучшей совместимости.
Web Browser SSO — один из примеров таких профилей.
Кроме того, стандарт определяет формат обмена метаинформацией между участниками, которая
включает список поддерживаемых ролей, протоколов, атрибутов, ключи шифрования и т. п.
Рассмотрим краткий пример использования SAML для сценария Single Sign-On. Пользователь хочет
получить доступ на защищенный ресурс сервис-провайдера (шаг № 1 на диаграмме аутентификации
пассивных клиентов). Т. к. пользователь не был аутентифицирован, SP отправляет его на сайт
identity provider’а для создания токена (шаг № 2). 

● Стандарты WS-Trust и WS-Federation
WS-Trust и WS-Federation входят в группу стандартов WS-*, описывающих SOAP/XML-веб сервисы.
Эти стандарты разрабатываются группой компаний, куда входят Microsoft, IBM, VeriSign и другие.
Наряду с SAML, эти стандарты достаточно сложные, используются преимущественно в корпоративных
сценариях.
Стандарт WS-Trust описывает интерфейс сервиса авторизации, именуемого Secure Token Service
(STS). Этот сервис работает по протоколу SOAP и поддерживает создание, обновление и
аннулирование токенов. При этом стандарт допускает использование токенов различного формата,
однако на практике в основном используются SAML-токены.
Стандарт WS-Federation касается механизмов взаимодействия сервисов между компаниями, в частности,
протоколов обмена токенов. При этом WS-Federation расширяет функции и интерфейс сервиса STS,
описанного в стандарте WS-Trust. Среди прочего, стандарт WS-Federation определяет:
1. Формат и способы обмена метаданными о сервисах.
2. Функцию единого выхода из всех систем (single sign-out).
3. Сервис атрибутов, предоставляющий дополнительную информацию о пользователе.
4. Сервис псевдонимов, позволяющий создавать альтернативные имена пользователей.
5. Поддержку пассивных клиентов (браузеров) посредством перенаправления.
Можно сказать, что WS-Federation позволяет решить те же задачи, что и SAML, однако их подходы
и реализация в некоторой степени отличаются.

● Стандарты OAuth и OpenID Connect
В отличие от SAML и WS-Federation, стандарт OAuth (Open Authorization) не описывает протокол
аутентификации пользователя. Вместо этого он определяет механизм получения доступа одного
приложения к другому от имени пользователя. Однако существуют схемы, позволяющие осуществить
аутентификацию пользователя на базе этого стандарта.
Чтобы лучше понять сам стандарт, рассмотрим пример веб-приложения, которое помогает
пользователям планировать путешествия. Как часть функциональности оно умеет анализировать почту
пользователей на наличие писем с подтверждениями бронирований и автоматически включать их в
планируемый маршрут. Возникает вопрос, как это веб-приложение может безопасно получить доступ
к почте пользователей, например, к Gmail?

> Попросить пользователя указать данные своей учетной записи? — плохой вариант.
> Попросить пользователя создать ключ доступа? — возможно, но весьма сложно.

Как раз эту проблему и позволяет решить стандарт OAuth: он описывает, как приложение
путешествий (client) может получить доступ к почте пользователя (resource server) с разрешения
пользователя (resource owner). В общем виде весь процесс состоит из нескольких шагов:
1. Пользователь (resource owner) дает разрешение приложению (client) на доступ к определенному
ресурсу в виде гранта. Что такое грант, рассмотрим чуть ниже.
2. Приложение обращается к серверу авторизации и получает токен доступа к ресурсу в обмен на
свой грант. В нашем примере сервер авторизации — Google. При вызове приложение дополнительно
аутентифицируется при помощи ключа доступа, выданным ему при предварительной регистрации.
3. Приложение использует этот токен для получения требуемых данных от сервера ресурсов
(в нашем случае — сервис Gmail).

** https://tyapk.ru/blog/post/authentication-methods
Методы аутентификации
WEB работает по протоколу HTTP, который не хранит состояние: каждый HTTP запрос ничего не
знает о том, что происходило до этого.

● Аутентификация на основе сессий
Самый распространённый и широко известный метод. Аутентификационная запись или сессия храниться на сервере и на клиенте. Сервер должен отслеживать активные сессии в базе данных или памяти, а на фронтенде создаётся кука, в которой хранится идентификатор сессии.
Процедура аутентификации на основе сессий:
1. Пользователь вводит в браузере своё имя и пароль, после чего клиентское приложение
отправляет на сервер запрос.
2. Сервер проверяет пользователя, аутентифицирует его, шлёт приложению уникальный
пользовательский токен (сохранив его в памяти или базе данных).
3. Клиентское приложение сохраняет токены в куках и отправляет их при каждом последующем
запросе.
4. Сервер получает каждый запрос, требующий аутентификации, с помощью токена аутентифицирует
пользователя и возвращает запрошенные данные клиентскому приложению.
5. Когда пользователь выходит, клиентское приложение удаляет его токен, поэтому все последующие
запросы от этого клиента становятся неаутентифицированными.

● Аутентификация на основе JWT (Json Web Tokens)
Процедура аутентификации на основе токенов:
1. Пользователь вводит имя и пароль.
2. Сервер проверяет их и возвращает токен (JWT), который может содержать метаданные вроде
user_id, разрешений и т. д.
3. Токен хранится на клиентской стороне, чаще всего в локальном хранилище, но может лежать
и в хранилище сессий или кук.
4. Последующие запросы к серверу обычно содержат этот токен в качестве дополнительного
заголовка авторизации в виде Bearer {JWT}. Ещё токен может пересылаться в теле POST-запроса
и даже как параметр запроса.
5. Сервер расшифровывает JWT, если токен верный, сервер обрабатывает запрос.
6. Когда пользователь выходит из системы, токен на клиентской стороне уничтожается, с сервером
взаимодействовать не нужно.

Преимущества:
1.Серверу не нужно хранить записи с пользовательскими токенами или сессиями. Каждый токен
самодостаточен, содержит все необходимые для проверки данные, а также передаёт затребованную
пользовательскую информацию. Поэтому токены не усложняют масштабирование.
2. В куках вы просто храните ID пользовательских сессий, а JWT позволяет хранить метаданные
любого типа, если это корректный JSON.
3. При использовании кук бэкенд должен выполнять поиск по традиционной SQL-базе или
NoSQL-альтернативе, и обмен данными наверняка длится дольше, чем расшифровка токена.
Кроме того, раз вы можете хранить внутри JWT дополнительные данные вроде пользовательских
разрешений, то можете сэкономить и дополнительные обращения поисковые запросы на получение
и обработку данных.
4. Допустим, у вас есть API-ресурс /api/orders, который возвращает последние созданные
приложением заказы, но просматривать их могут только пользователи категории админов. Если вы
используете куки, то, сделав запрос, вы генерируете одно обращение к базе данных для проверки
сессии, ещё одно обращение — для получения пользовательских данных и проверки, относится ли
пользователь к админам, и третье обращение — для получения данных.
5. А если вы применяете JWT, то можете хранить пользовательскую категорию уже в токене. Когда
сервер запросит его и расшифрует, вы можете сделать одно обращение к базе данных, чтобы
получить нужные заказы.
6. У использования кук на мобильных платформах есть много ограничений и особенностей. А токены
сильно проще реализовать на iOS и Android. К тому же токены проще реализовать для приложений
и сервисов интернета вещей, в которых не предусмотрено хранение кук.

● Беспарольная аутентификация
Работает на основе одноразовых ссылок. Вводится только почта/телефон. Ваше приложение отправляет
туда одноразовую ссылку, пользователь по ней кликает и автоматически входит на ваш сайт
/ в приложение. При беспарольной аутентификации приложение считает, что в ваш ящик пришло
письмо со ссылкой, если вы написали свой, а не чужой адрес.
Недостаток: если кто-то получит доступ к пользовательским почтам, он получит и доступ к
приложениям и сайтам.
Преимущество: нет необходиомсти реализовывать механизм восстановления паролей.

● Аутентификация через единую точку входа (SSO)
Метод Single Sign On. Существуют различные реализации. Рассмотрим на примере Google Accounts.
Когда логинишься в одном Google-сервисе, например Gmail, а потом получаешь доступ к остальным
Google-сервисам без аутентификации, то ты пользуешься единую точку входа от Google. Удобно не
правда ли? Процедура аутентификации на Google Accounts (SSO):
Пользователь входит в один из сервисов Google.
Пользователь получает сгенерированную в Google Accounts куку.
Пользователь идёт в другой продукт Google.
Пользователь снова перенаправляется в Google Accounts.
Google Accounts видит, что пользователю уже присвоена кука, и перенаправляет пользователя в
запрошенный продукт.
В этой процедуре используется три сущности:
user
identity provider
service provider
Пользователь вводит пароль (или аутентифицируется иначе) у поставщика идентификационной
информации (identity provider, IDP), чтобы получить доступ к поставщику услуги (service
provider (SP)). Пользователь доверяет IDP, и SP доверяет IDP, так что SP может доверять
пользователю.

** https://habr.com/ru/post/533868/ 
Токен авторизации на примере JSON WEB Token
JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа,
основанный на формате JSON. 
Фактически это просто строка символов (закодированная и подписанная определенными алгоритмами)
с некоторой структурой, содержащая полезные данные пользователя, например ID, имя, уровень
доступа и так далее. И эта строчка передается клиентом приложению при каждом запросе, когда
есть необходимость идентифицировать и понять кто прислал этот запрос.
Принцип работы
Рассмотрим принцип работы клиент серверных приложений, работающих с помощью JWT. Первым делом
пользователь проходит аутентификацию, конечно же если не делал этого ранее и в этом есть
необходимость, а именно, например, вводит свой логин и пароль. Далее приложение выдаст ему
2 токена: access token и refresh token.
Пользователь тем или иным способом сохраняет его себе, например, в локальном хранилище или
в хранилище сессий. Затем, когда пользователь делает запрос к API приложения он добавляет
полученный ранее access token. И наконец наше приложение, получив данный запрос с токеном,
проверяет что данный токен действительный (об этой проверке, опять же, ниже), вычитывает
полезные данные, которые помогут идентифицировать пользователя и проверить, что он имеет
право на запрашиваемые ресурсы. Таким нехитрым образом происходит основная логика работы
с JSON Web Tokens.

Структура токена
Пришло время обсудить структуру токена и тем самым лучше разобраться в его работе. Первое
что следует отметить, что JWT токен состоит из трех частей, разделенных через точку:
Заголовок (header)
Полезные данные (playload)
Подпись (signature)

Заголовок
Это первая часть токена. Она служит прежде всего для хранения информации о токене, которая
должна рассказать о том, как нам прочитать дальнейшие данные, передаваемые JWT. Заголовок
представлен в виде JSON объекта, закодированного в Base64-URL 
Например:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
Если раскодировать данную строку получим:
{"alg":"HS256","typ":"JWT"}
Заголовок содержит два главных поля: alg и typ. Поле typ служит для информации о типе токена,
но как я уже упоминал ранее, что JWT превратился в некий стандарт, то это поле перестало нести
особый смысл и служит скорее для целей будущего, если вдруг появится улучшенная версия
алгоритма JWT(2.0), которая заменит JWT. Поле alg задает алгоритм шифрования. Обязательный
для поддержки всеми реализациями является алгоритм HMAC с использованием SHA-256, или же,
как он обозначен в заголовке, HS256. Для работы с этим алгоритмом нужен один секретный ключ
конкретный механизм работы рассмотрим ниже. Для справки можно также отметить, что существует
и асимметричный алгоритм, который можно использовать в JWT, например, RS256. Для работы с
ним требуется два ключа - открытый и закрытый.

Полезные данные
Перейдем наконец к полезным данным. Опять же - это JSON объект, который для удобства и
безопасности передачи представляется строкой, закодированной в base64. Наглядный пример
полезных данных (playload) токена может быть представлен следующей строкой:
eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9
Что в JSON формате представляет собой:
{"user_id":1,"exp":1581357039}
Именно здесь хранится вся полезная информация. Для данной части нет обязательных полей, из
наиболее часто встречаемых можно отметить следующие:
iss - используется для указания приложения, из которого отправляется токен.
user_id - для идентификации пользователя в нашем приложении, кому принадлежит токен.
Одной из самых важных характеристик любого токена является время его жизни, которое может
быть задано полем exp. По нему происходит проверка, актуален ли токен еще (что происходит,
когда токен перестает быть актуальным можно узнать ниже). Как я уже упоминал, токен может
помочь с проблемой авторизации, именно в полезных данных мы можем добавить свои поля, которые
будут отражать возможности взаимодействия пользователя с нашим приложением. Например,
мы можем добавить поле is_admin или же is_preferUser, где можем указать имеет ли пользователь
права на те или иные действия, и при каждом новом запросе с легкостью проверять, не
противоречат ли запрашиваемые действия с разрешенными. Ну а что же делать, если попробовать
изменить токен и указать, например, что мы являемся администраторами, хотя таковыми никогда
не были.

Подпись
На данный момент мы поняли, что пока токен никак не защищен и не зашифрован, и любой может
изменить его и тем самым нарушается вообще весь смысл аутентификации. Эту проблему призвана
решить последняя часть токена - а именно сигнатура (подпись). Происходит следующее: наше
приложение при прохождении пользователем процедуры подтверждения, что он тот за кого себя
выдает, генерирует этот самый токен, определяет поля, которые нужны, записывает туда данные,
которые характеризуют данного пользователя, а дальше с помощью заранее выбранного алгоритма
(который отмечается в заголовке в поле alg токена), например HMAC-SHA256, и с помощью своего
приватного ключа (или некой секретной фразы, которая находится только на серверах приложения
все данные токена подписываются. И затем сформированная подпись добавляется, также в формате
base64, в конец токена. Таким образом наш итоговый токен представляет собой закодированную и
подписанную строку. И далее при каждом новом запросе к API нашего приложения, сервер с помощью
своего секретного ключа сможет проверить эту подпись и тем самым убедиться, что токен не был
изменен. Эта проверка представляет собой похожую на подпись операцию, а именно, получив токен
при новом запросе, он вынимает заголовок и полезные данные, затем подписывает их своим
секретным ключом, и затем идет просто сравнение двух получившихся строк. Таким нехитрым
способом, если не скомпроментировать секретный ключ, мы всегда можем знать, что перед нами
все еще наш %user_name% с четко отведенными ему правами.

Время жизни токена и Refresh Token
Теперь плавно перейдем к следующему вопросу - времени жизни токена, и сопутствующей этой теме
refresh token. Мы помним, что одно из важнейших свойств токена - это время его жизни. И оно
совсем недолговечное, а именно 10-30 минут. Может возникнуть вопрос: а зачем такое короткое
время жизни, ведь тогда придется каждый раз заново создавать новый токен, а это лишняя
нагрузка на приложения. А ответ достаточно очевидный, который включает в себя и одновременно
ответ на вопрос: а что делать если токен был перехвачен. Действительно, если токен был
перехвачен, то это большая беда, так как злоумышленник получает доступ к приложению от имени
нашего %user_name%, но так как access token является короткоживущим, то это происходит лишь
на недолгий период. А дальше этот токен уже является не валидным. И именно чтобы обновить и
получить новый access token нужен refresh token. Как мы знаем (или если забыли можем снова
прочитать в начале) пользователь после процесса аутентификацию получает оба этих токена. И
теперь по истечении времени жизни access token мы отсылаем в приложение refresh token и в
ответ получаем снова два новых токена, опять же один многоразовый, но ограниченный по
времени - токен доступа, а второй одноразовый, но долгоживущий - токен обновления. Время
жизни refresh token вполне может измеряться месяцами, что достаточно для активного 
ользователя, но в случае если и этот токен окажется не валидным, то пользователю следует
заново пройти идентификацию и аутентификацию, и он снова получит два токена. И весь механизм
работы повторится.